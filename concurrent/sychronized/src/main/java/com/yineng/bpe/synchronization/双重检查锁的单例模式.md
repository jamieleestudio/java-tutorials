
# 单例模式
~~~

public class SynchronizedDoubleCheck {

    private  static SynchronizedDoubleCheck singleSynchronizedDoubleCheck;

    private SynchronizedDoubleCheck(){}

    public static SynchronizedDoubleCheck getInstance(){
        if(singleSynchronizedDoubleCheck == null){
             singleSynchronizedDoubleCheck = new SynchronizedDoubleCheck();
        }
        return  singleSynchronizedDoubleCheck;
    }

    public static void main(String[] args) {
        System.out.println(SynchronizedDoubleCheck.getInstance() == SynchronizedDoubleCheck.getInstance());
    }
}

~~~
当在多线程的环境下 ，为空判断时，多个线程会进入这个判断，多个线程会创建多个对象，导致多个对象

~~~
if(singleSynchronizedDoubleCheck == null){
        singleSynchronizedDoubleCheck = new SynchronizedDoubleCheck();
}
~~~

所以我们为他加上锁

~~~

public class SynchronizedDoubleCheck {

    //volatile 可见性，一个线程对变量的修改对另一个线程可见
    private volatile static SynchronizedDoubleCheck singleSynchronizedDoubleCheck;

    private SynchronizedDoubleCheck(){}

    public static SynchronizedDoubleCheck getInstance(){
        if(singleSynchronizedDoubleCheck == null){
            synchronized (SynchronizedDoubleCheck.class){
                    singleSynchronizedDoubleCheck = new SynchronizedDoubleCheck();
            }
        }
        return singleSynchronizedDoubleCheck;
    }
}

~~~
但依然有可能多个线程通过了第一个为空判断，比如当两个线程排队等待锁释放，则会新建多个对象，所以我们再加第二次判断

~~~
public class SynchronizedDoubleCheck {

    //volatile 可见性，一个线程对变量的修改对另一个线程可见
    private volatile static SynchronizedDoubleCheck singleSynchronizedDoubleCheck;

    private SynchronizedDoubleCheck(){}

    public static SynchronizedDoubleCheck getInstance(){
        if(singleSynchronizedDoubleCheck == null){
            synchronized (SynchronizedDoubleCheck.class){
                 if(singleSynchronizedDoubleCheck == null){
                    singleSynchronizedDoubleCheck = new SynchronizedDoubleCheck();
                }
            }
        }
        return singleSynchronizedDoubleCheck;
    }
}
~~~


这样看起来没什么问题，其实隐患在于new 操作
~~~
        singleSynchronizedDoubleCheck = new SynchronizedDoubleCheck();
~~~

这行代码并不是一个原子操作。它实际上可以分解为以下三个步骤（伪代码）：

- singleSynchronizedDoubleCheck = new SynchronizedDoubleCheck() // 1. 为 Singleton 对象分配一块内存空间
- ctorInstance(memory); // 2. 在这块内存上调用构造函数，初始化对象
- instance = memory; // 3. 将 instance 引用指向这块内存地址

关键在于：步骤 2 和步骤 3 可能会被 JVM、编译器或处理器进行指令重排序（Reorder）。重排序后的顺序可能变成 1 -> 3 -> 2。


### 假设发生了指令重排序，我们来看一个多线程下的执行时序：
| 时间 | 线程 A                                                                | 线程 B                                              |
|----|---------------------------------------------------------------------|---------------------------------------------------|
| t1 | 执行 getInstance()，第一次检查 instance == null 为 true                      |                                                   |
| t2 | 进入 synchronized 块                                                   |                                                   |
| t3 | 第二次检查 instance == null 为 true                                       |                                                   |
| t4 | 开始执行 singleSynchronizedDoubleCheck = new SynchronizedDoubleCheck(); |                                                   |
| t5 | 步骤 1：分配内存                                                           |                                                   |
| t6 | 步骤 3：instance 指向分配的内存（此时 instance != null，但对象未初始化！）                 |                                                   |
| t7 |                                                                     | 执行 getInstance()，第一次检查 instance == null，发现不为 null |
| t8 |                                                                     | 直接返回这个尚未初始化的 instance 引用并使用 → 程序出错！               |
| t9 | 步骤 2：初始化对象（但为时已晚）                                                   |                                                   |

### 使用 volatile
volatile 关键字在这里解决了有序性问题。它为 instance 变量的写操作提供了一个内存屏障（Memory Barrier），禁止了步骤 2（初始化）和步骤 3（赋值引用）之间的重排序。

volatile 在这里的作用：

- 保证可见性：当一个线程完成 instance = new Singleton(); 后，新值会立即对其他线程可见。
- 防止指令重排序：最重要的是，它确保了 new Singleton() 这个过程内部的步骤不会被重排序。对象一定会先被完全初始化，然后才将引用赋值给 instance 变量。这样，其他线程在第一次检查时看到的 instance 要么是 null，要么就是一个已经完全构造好的对象，绝不会是一个中间状态。